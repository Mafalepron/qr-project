import logging
import os
import httpx
from dotenv import load_dotenv
from telegram import Update, WebAppInfo, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Application, CommandHandler, ContextTypes, MessageHandler, filters
from PIL import Image
from pyzbar.pyzbar import decode
from io import BytesIO

# –ó–∞–≥—Ä—É–∂–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
load_dotenv()

# –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
BACKEND_API_URL = os.getenv("BACKEND_API_URL", "http://127.0.0.1:8000")
ADMIN_IDS = [int(admin_id) for admin_id in os.getenv("ADMIN_IDS", "0").split(",")]


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /start. –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ –∏–Ω—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç –∞–¥–º–∏–Ω–æ–≤."""
    user = update.effective_user
    await update.message.reply_html(
        f"–ü—Ä–∏–≤–µ—Ç, {user.mention_html()}!\n\n"
        f"–Ø –±–æ—Ç –¥–ª—è –≤—ã–¥–∞—á–∏ QR-–∫–æ–¥–æ–≤ –Ω–∞ –º–µ—Ä–æ–ø—Ä–∏—è—Ç–∏–µ. "
        f"–ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Å–≤–æ–π —É–Ω–∏–∫–∞–ª—å–Ω—ã–π QR-–∫–æ–¥, –≤–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É /get_qr.",
    )
    if update.effective_user.id in ADMIN_IDS:
        await update.message.reply_text(
            "–í—ã –≤–æ—à–ª–∏ –∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É /scan –¥–ª—è –∑–∞–ø—É—Å–∫–∞ —Å–∫–∞–Ω–µ—Ä–∞ QR-–∫–æ–¥–æ–≤."
        )


async def get_qr(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É /get_qr. –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç —É –±—ç–∫–µ–Ω–¥–∞ QR-–∫–æ–¥ –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é."""
    user = update.effective_user
    telegram_id = str(user.id)
    logger.info(f"User {telegram_id} ({user.first_name}) requested a QR code.")

    try:
        # 1. –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å –Ω–∞ backend –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è QR-–∫–æ–¥–∞
        async with httpx.AsyncClient() as client:
            payload = {
                "telegram_id": telegram_id,
                "user_first_name": user.first_name,
                "user_username": user.username
            }
            response = await client.post(
                f"{BACKEND_API_URL}/qrcodes/",
                json=payload,
                timeout=20.0
            )
            response.raise_for_status()
            qr_data = response.json()
            qr_code_id = qr_data.get("id")

            if not qr_code_id:
                raise ValueError("Backend did not return a QR code ID.")

            logger.info(f"Successfully created/retrieved QR code with id {qr_code_id} for user {telegram_id}")

            # 2. –°–∫–∞—á–∏–≤–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ QR-–∫–æ–¥–∞ –æ—Ç backend
            image_url = f"{BACKEND_API_URL}/qrcodes/{qr_code_id}/image"

            async with httpx.AsyncClient() as client:
                image_response = await client.get(image_url, timeout=20.0)
                image_response.raise_for_status()
                image_bytes = image_response.content

            await update.message.reply_photo(
                photo=image_bytes,
                caption="–í–∞—à —É–Ω–∏–∫–∞–ª—å–Ω—ã–π QR-–∫–æ–¥. –ü—Ä–µ–¥—ä—è–≤–∏—Ç–µ –µ–≥–æ –Ω–∞ –≤—Ö–æ–¥–µ."
            )
    except httpx.RequestError as e:
        logger.error(f"Could not connect to backend: {e}")
        await update.message.reply_text(
            "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≤—è–∑–∞—Ç—å—Å—è —Å —Å–µ—Ä–≤–µ—Ä–æ–º. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )
    except Exception as e:
        logger.error(f"An error occurred in get_qr for user {telegram_id}: {e}")
        await update.message.reply_text(
            "–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ QR-–∫–æ–¥–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
        )


async def scan_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """(–¢–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤) –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç –∫–Ω–æ–ø–∫—É –¥–ª—è –∑–∞–ø—É—Å–∫–∞ Web App —Å–∫–∞–Ω–µ—Ä–∞."""
    user_id = update.effective_user.id
    if user_id not in ADMIN_IDS:
        return

    public_url = os.getenv('PUBLIC_URL')
    if not public_url:
        await update.message.reply_text("–û—à–∏–±–∫–∞: –ü—É–±–ª–∏—á–Ω—ã–π URL (PUBLIC_URL) –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω –≤ .env —Ñ–∞–π–ª–µ. –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.")
        return
    
    if not public_url.startswith("https://"):
        await update.message.reply_text(
            "–û—à–∏–±–∫–∞: –ü—É–±–ª–∏—á–Ω—ã–π URL –¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å https://. "
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —É–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã –∏—Å–ø–æ–ª—å–∑—É–µ—Ç–µ ngrok –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—ã–π —Å–µ—Ä–≤–∏—Å –∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ —É–∫–∞–∑–∞–ª–∏ URL."
        )
        return
        
    scanner_url = f"{public_url}/scanner"
    # –°–æ–∑–¥–∞–µ–º –∫–Ω–æ–ø–∫—É, –∫–æ—Ç–æ—Ä–∞—è –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç Web App
    keyboard = [[InlineKeyboardButton("üöÄ –û—Ç–∫—Ä—ã—Ç—å —Å–∫–∞–Ω–µ—Ä", web_app=WebAppInfo(url=scanner_url))]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å —ç—Ç–æ–π –∫–Ω–æ–ø–∫–æ–π
    await update.message.reply_text(
        "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –∫–∞–º–µ—Ä—É –∏ –Ω–∞—á–∞—Ç—å —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ.",
        reply_markup=reply_markup
    )


async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if user_id not in ADMIN_IDS:
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(f"{BACKEND_API_URL}/stats", timeout=10)
            data = response.json()
            await update.message.reply_text(
                f"üìä –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
                f"‚úÖ –í—Å–µ–≥–æ —É—Å–ø–µ—à–Ω–æ: {data.get('success', 0)}\n"
                f"‚õî –í—Å–µ–≥–æ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ: {data.get('fail', 0)}"
            )
    except Exception as e:
        await update.message.reply_text("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏.")


async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    """–õ–æ–≥–∏—Ä—É–µ—Ç –æ—à–∏–±–∫–∏, –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –æ—Ç Telegram."""
    logger.error("–ü—Ä–æ–∏–∑–æ—à–ª–æ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è:", exc_info=context.error)


def main() -> None:
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç –±–æ—Ç–∞."""
    if not TELEGRAM_BOT_TOKEN:
        logger.error("–¢–æ–∫–µ–Ω –±–æ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ .env —Ñ–∞–π–ª–µ! –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã.")
        return

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("get_qr", get_qr))
    application.add_handler(CommandHandler("scan", scan_command))
    application.add_handler(CommandHandler("stats", stats_command))
    
    application.add_error_handler(error_handler)

    logger.info("Starting bot...")
    application.run_polling()


if __name__ == "__main__":
    main()
